


package t_if;

typedef struct {
 
	bit       req;
	logic     cmd; 
	bit[31:0] addr;
	bit[31:0] data;
  
} t_st;

endpackage 


package p_rd;

typedef struct {
 
	bit       ack;
	bit[31:0] data;
  
} t_rd;

endpackage 



//module cross_bar(input bit clk, input t_if::t_st mst[2], output t_if::t_st slv[2], input bit[31:0] rd_data[2]);


module cross_bar(input bit clk, input t_if::t_st mst[2], output t_if::t_st slv[2], 
                                input p_rd::t_rd slv_cross[2], output p_rd::t_rd cross_mst[2]);

//module cross_bar(input bit clk, input bit[31:0] addr[2], wr_data[2], input cmd[2], input bit req[2], ack[2], input bit[31:0] rd_data[2],
//					  output bit[31:0] s_addr[2], s_wr_data[2], output s_cmd[2], output bit s_req[2], sm_ack[2], output bit[31:0] sm_rd_data[2]);
/*
	always @(posedge clk) begin

		slv <= mst;
		
	end	
*/
//bit      prv = 0;					  
bit sel = 0;

			
	always @(posedge clk) begin
	
	
		if(mst[0].addr[31] != mst[1].addr[31]) begin
		
			slv[mst[0].addr[31]] <= mst[0]; 
			slv[mst[1].addr[31]] <= mst[1]; 
						
			cross_mst[mst[0].addr[31]] <= slv_cross[0];
			cross_mst[mst[1].addr[31]] <= slv_cross[1];
			
			//slv[mst[0].addr[31]] <= mst[mst[0].addr[31]]; 
			//slv[mst[1].addr[31]] <= mst[mst[1].addr[31]]; 
		end
	   else begin
		
				slv[mst[0].addr[31]] <= mst[sel]; 
// if(.....) ?				
				sel <= ~sel; 
		end
			
/*		
		if(mst[0].addr[31] != prv) begin
		
			prv <= mst[0].addr[31];
			++sel;// <= sel + 1;
				
		end
		
		slv[sel] <= mst[mst[0].addr[31]]; 
*/		
		
//		slv[{mst[0].addr[31], mst[1].addr[31]} >> 1] <= mst[{mst[0].addr[31], mst[1].addr[31]}]; 
//		slv[{mst[0].addr[31], mst[1].addr[31]} >> 1] <= mst[mst[0].addr[31]]; 
		

//		{s_addr[sel], s_wr_data[sel], s_cmd[sel], s_req[sel], sm_ack[sel], sm_rd_data[sel]} <= 
//		{addr[sel], wr_data[sel], cmd[sel], req[sel], ack[sel], rd_data[sel]};
	
	end

endmodule: cross_bar


	/*
		case({mst[0].addr[31], mst[1].addr[31]})
		
		
			2'b00, 
			2'b01: begin
			
						slv[0] <= mst[{mst[0].addr[31], mst[1].addr[31]}]; 
			
					 end
					  
			2'b10, 
			2'b11: begin
			
						slv[1] <= mst[{mst[0].addr[31], mst[1].addr[31]}]; 
			
					 end
				
		endcase
		*/
